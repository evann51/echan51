<!DOCTYPE html>
<!-- for gsop project -->
<html>
<head>
    <meta charset="UTF-8">
    <title>BitLife</title>
    <style>
      @import url('https://fonts.cdnfonts.com/css/avenir');
    </style>
</head>
<body onload = startGame()>

    <script>
        //sizing
        var cHeight = 720;
        var cWidth = 1280;
        var bHeight;
        var bWidth;
        var canvasBound = [1280/2,1280*2]//1920x1080 is most common screen size, 200% zoomability is recommended for wcag guidelines

        //animations
        var frameCount;

        //game logic stuffs
        var age;
        var name;
        var story;

        //info stuffs
        var charts;
        var stats;

        //UI
        var ageButton = [0,0,"#0aad36"];
        var storyBounds = [0,0];


        function startGame(){
            resetGame();

            board.start();
        }//startGame

        function resetGame(){
            age = 0;
            frameCount = 0;

            charts = [];
            charts.length = 2;
            charts[0] = new Chart('Survival', 72.9);
            charts[1] = new Chart('Poopy', 14.3)


        }//resetGame

        var board = {
            c : document.createElement("canvas"),
            start : function() {
                this.c.width = cWidth;
                this.c.height = cHeight;
                this.context = this.c.getContext("2d");
                document.body.insertBefore(this.c, document.body.childNodes[0]);
                this.frameNo = 0;
                this.interval = setInterval(updateGameArea, 20);
            },
            clear : function() {
                this.context.clearRect(0, 0, this.c.width, this.c.height);
            }
        }//board

        function updateGameArea(){
            frameCount++;

            resizeGameArea();
            display();
        }//updateGameArea

        function resizeGameArea(){
            bWidth = window.innerWidth;
            bHeight = window.innerHeight;

            cWidth = (2/3)*bWidth;

            if(cWidth>canvasBound[1]){
                cWidth = canvasBound[1];
            }
            else if (cWidth<canvasBound[0]){
                cWidth = canvasBound[0];
                console.log(cWidth);
            }

            cHeight = (1080/1920)*cWidth;//keeps ratio of 1920:1080

            board.c.height = cHeight;
            board.c.width = cWidth;

            ageButton = [cWidth*1/3,cHeight*0.80,ageButton[2]];
        }//resizeGameArea

        function display(){
            this.ctx = board.context;
            this.ctx.save();

            //stats panel
            this.ctx.fillStyle = "#f5f4f2";
            fillRoundRect(cWidth*0.6,0,cWidth*0.3666,cHeight,cHeight/40);
            this.ctx.fillRect(cWidth*2/3,0,cWidth/6,cHeight);

            //game background
            this.ctx.shadowColor = "#9c9c9c";
            this.ctx.shadowBlur = 15;
            this.ctx.fillStyle = "#f23f3f";
            fillRoundRect(0,0,cWidth*2/3,cHeight,cHeight/40);
            this.ctx.restore();
            this.ctx.save();
            this.ctx.fillStyle = "#f23f3f";
            this.ctx.clearRect(0,0,cWidth/2,cHeight);
            fillRoundRect(0,0,cWidth*6/10,cHeight,cHeight/40);

            //ui+lifescreen
            this.ctx.shadowColor = "#b52d2d";//red shadow
            this.ctx.shadowBlur = 20;
            this.ctx.shadowOffsetX = 0;
            this.ctx.shadowOffsetY = 0;
            this.ctx.fillStyle = "#f0f0f0";

            this.ctx.fillRect(15,cHeight*3/4,(cWidth*2/3)-30,cHeight*0.1);//red shadow from bottom ui on red bg
            this.ctx.fillRect(15,cHeight*0.05,(cWidth*2/3)-30,cHeight*0.05,cHeight/40);//red shadow from top ui on red bg
            this.ctx.fillRect(cWidth/20,0,(cWidth*2/3)-(cWidth/20)*2,cHeight);//white life screen with red shadow on red bg

            this.ctx.shadowColor = "#949494";//lifescreen and shadows on lifescreen
            fillCircle(ageButton[0],ageButton[1],cWidth*0.08);
            this.ctx.fillRect((cWidth*0.05)-7.5,cHeight*3/4,(cWidth*2/3)-(cWidth*0.1)+15,cHeight*0.1);
            this.ctx.fillRect((cWidth*0.05)-10,cHeight*.05,(cWidth*2/3)-(cWidth*0.1)+20,cHeight*0.05);
            this.ctx.fillStyle = "#e3e3e3";
            this.ctx.shadowColor = 'rgba(0,0,0,0)';

            this.ctx.fillRect(0,cHeight*.05,(cWidth*2/3),cHeight*0.05);
            fillRoundRect(0,-.5,cWidth*(2/3)+0.005,cHeight*0.1,cHeight/40);
            this.ctx.fillRect(0,cHeight*6/8,cWidth*2/3,(cHeight*1/6));
            this.ctx.clearRect(0,cHeight*.8,cWidth*0.2,cHeight*.2);
            fillRoundRect(0,cHeight*6/8,cWidth*2/3,(cHeight*1/4)+1,cHeight/40);
            fillCircle(ageButton[0],ageButton[1],cWidth*0.08);
            this.ctx.fillStyle = ageButton[2];
            fillCircle(ageButton[0],ageButton[1],cWidth*0.075);
            this.ctx.fillStyle = "#e3e3e3";
            fillCircle(ageButton[0],ageButton[1],cWidth*0.073);
            this.ctx.fillStyle = ageButton[2];
            fillCircle(ageButton[0],ageButton[1],cWidth*0.070);
            this.ctx.fillStyle = "#e3e3e3";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.font = cHeight/25 + "px Avenir medium";
            this.ctx.fillText("Age",cWidth*1/3,cHeight*0.87);
            fillRoundRect((cWidth*1/3)-(cWidth*0.0070)/2,cHeight*0.70,cWidth*0.0070,cHeight*0.13,cHeight/40);
            fillRoundRect((cWidth*1/3)-(cHeight*0.13)/2,cHeight*0.76,(cHeight*0.13),(cWidth*0.0070),cHeight/40);



            displayCharts();

            this.ctx.restore();
        }//display

        function displayCharts(){//will add scroll bar later
            this.ctx = board.context;

            this.ctx.fillStyle = "#03041a";

            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.fontSize = cWidth/40;
            this.ctx.font = fontSize+'px Avenir medium';
            this.ctx.fillText("Stats",cWidth*5/6,cHeight*1/10);

            this.ctx.textAlign = "right";
            this.fontSize = cWidth/70;
            this.ctx.font = fontSize+'px Avenir medium';
            for(i = 0;i<charts.length;i++){
                if(frameCount%1==0){
                    charts[i].updateStat();
                }
                let x = (cWidth*2/3)+cWidth/11;
                let y = (cHeight*1/6)+(this.fontSize*i*2);

                charts[i].display(x,y,this.fontSize*2);
            }
        }//displayCharts

        class Chart{
            constructor(name, stat){
                this.name = name;
                this.stat = stat;
                this.animStat = stat;
            }//constructor

            display(x,y,sp){
                this.ctx = board.context;
                this.ctx.fillStyle = "#03041a";
                this.ctx.textAlign = "right";
                this.ctx.font = sp/2 + "px Avenir medium";
                this.ctx.fillText(this.name,x,y);

                this.ctx.fillStyle = "#dedede";
                fillRoundRect(x+sp/3,y-sp/8,(cWidth*3/22),sp/4,cWidth/80)
                if(this.stat<25){
                    this.ctx.fillStyle = lerpColor([232, 19, 19],[250, 200, 2],this.stat*.01)
                }
                else{
                    this.ctx.fillStyle = lerpColor([250, 200, 2],[36, 245, 0],(this.stat*0.01)-0.25);
                }
                fillRoundRect(x+sp/3,y-sp/8,(cWidth*3/22)*this.animStat*0.01,sp/4,cWidth/80)

                this.ctx.fillStyle = "#03041a";
                this.ctx.textAlign = "left";
                this.ctx.fillText(this.animStat.toFixed(1)+"%",x+(cWidth*3/22)+sp/2,y);
            }//display

            updateStat(newStat){
                this.animStat+=(this.stat-this.animStat)/8;
                if((this.animStat-this.stat)*(this.animStat-this.stat)<=3){
                    this.animStat = this.stat;
                }
            }//updateStat

            changeStat(newStat){
                this.stat = roundToNearestTenth(newStat);
            }//changeStat
        }//Chart class

        class Human{



        }//Human

        board.c.addEventListener('mousemove', (event) => {
          const rCanvas = board.c.getBoundingClientRect();
          const mouseX = event.clientX - rCanvas.left;
          const mouseY = event.clientY - rCanvas.top;
          if (getDistance(ageButton[0],ageButton[1],mouseX,mouseY)<cHeight*0.07*2){
            ageButton[2] = "#45b54a";
          }
          else{
            ageButton[2] = "#0aad36";
          }

        });//mouse hovering

        //Helper Functions
        function fillRoundRect(x,y,w,l,r){
            this.ctx = board.context;

            this.ctx.beginPath();
            this.ctx.roundRect(x,y,w,l,r);
            this.ctx.fill();
            this.ctx.closePath();

        }//fillRoundRect - makes a filled rounded rectangle

        function fillCircle(x,y,r){
            this.ctx = board.context;

            this.ctx.beginPath();
            this.ctx.arc(x,y,r,0,2*Math.PI);
            this.ctx.fill();
            this.ctx.closePath();
        }//fillCircle - fills a circle..

        function lerp(x1,x2,v){
            return x1 * (1 - v) + x2 * v;
        }//lerp - gets an intermediate value between x1 and x2 based on v. v=1 will return x2

        function lerpColor(color1, color2, amt) {
            let r = lerp(color1[0], color2[0], amt);
            let g = lerp(color1[1], color2[1], amt);
            let b = lerp(color1[2], color2[2], amt);

            return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
        }//lerpColor

        function getRandomInt(min, max) {
            const minCeiled = Math.ceil(min);
            const maxFloored = Math.floor(max);
            return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled);
        }//getRandomInt gets random integer with exclusive max and inclusive minimum

        function roundToNearestTenth(num) {
            return Math.round(num * 10)/10;
        }//roundToNearestTenth

    function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        // First, start by splitting all of our text into words, but splitting it into an array split by spaces
        let words = text.split(' ');
        let line = ''; // This will store the text of the current line
        let testLine = ''; // This will store the text when we add a word, to test if it's too long
        let lineArray = []; // This is an array of lines, which the function will return

        // Lets iterate over each word
        for(var n = 0; n < words.length; n++) {
            // Create a test line, and measure it..
            testLine += `${words[n]} `;
            let metrics = ctx.measureText(testLine);
            let testWidth = metrics.width;
            // If the width of this test line is more than the max width
            if (testWidth > maxWidth && n > 0) {
                // Then the line is finished, push the current line into "lineArray"
                lineArray.push([line, x, y]);
                // Increase the line height, so a new line is started
                y += lineHeight;
                // Update line and test line to use this word as the first word on the next line
                line = `${words[n]} `;
                testLine = `${words[n]} `;
            }
            else {
                // If the test line is still less than the max width, then add the word to the current line
                line += `${words[n]} `;
            }
            // If we never reach the full max width, then there is only one line.. so push it into the lineArray so we return something
            if(n === words.length - 1) {
                lineArray.push([line, x, y]);
            }
        }
        // Return the line array
        return lineArray;
    }//wrapText not by me...from the intertrash

    function getDistance(x1, y1, x2, y2) {
        const xDiff = x2 - x1;
        const yDiff = y2 - y1;
        return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
    }//getDistance
    </script>

</body>
</html>
