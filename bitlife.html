<!DOCTYPE html>
<!-- for gsop project -->
<html>
<head>
    <meta charset="UTF-8">
    <title>BitLife</title>
</head>
<body onload = startGame()>

    <script>
        //sizing
        var cHeight = 720;
        var cWidth = 1280;
        var bHeight;
        var bWidth;
        var canvasBound = [1280/2,1280*2]//1920x1080 is most common screen size, 200% zoomability is recommended for wcag guidelines

        //animations
        var frameCount;

        //game logic stuffs
        var age;
        var name;

        //info stuffs
        var charts;
        var stats;

        //UI

        var ageButton;


        function startGame(){
            resetGame();

            board.start();
        }//startGame

        function resetGame(){
            age = 0;
            frameCount = 0;
            
            charts = [];
            charts.length = 2;
            charts[0] = new Chart('Survival', 72.9);
            charts[1] = new Chart('Poopy', 14.3)
            
            
        }//resetGame

        var board = {
            c : document.createElement("canvas"),
            start : function() {
                this.c.width = cWidth;
                this.c.height = cHeight;
                this.context = this.c.getContext("2d");
                document.body.insertBefore(this.c, document.body.childNodes[0]);
                this.frameNo = 0;
                this.interval = setInterval(updateGameArea, 20);
            },
            clear : function() {
                this.context.clearRect(0, 0, this.c.width, this.c.height);
            }
        }//board
        
        function updateGameArea(){
            frameCount++;
            
            resizeGameArea();
            display();
        }//updateGameArea

        function resizeGameArea(){
            bWidth = window.innerWidth;
            bHeight = window.innerHeight;

            cWidth = (2/3)*bWidth;

            if(cWidth>canvasBound[1]){
                cWidth = canvasBound[1];
            }
            else if (cWidth<canvasBound[0]){
                cWidth = canvasBound[0];
                console.log(cWidth);
            }

            cHeight = (1080/1920)*cWidth;//keeps ratio of 1920:1080

            board.c.height = cHeight;
            board.c.width = cWidth;
        }//resizeGameArea

        function display(){
            this.ctx = board.context;
            this.ctx.save();

            //stats panel
            this.ctx.fillStyle = "#f5f4f2";
            fillRoundRect(cWidth*0.6,0,cWidth*0.3666,cHeight,cHeight/40);
            this.ctx.fillRect(cWidth*2/3,0,cWidth/6,cHeight);

            //game background
            this.ctx.shadowColor = "#9c9c9c";
            this.ctx.shadowBlur = 15;
            this.ctx.fillStyle = "#f23f3f";
            fillRoundRect(0,0,cWidth*2/3,cHeight,cHeight/40);
            this.ctx.restore();
            this.ctx.save();
            this.ctx.fillStyle = "#f23f3f";
            this.ctx.clearRect(0,0,cWidth/2,cHeight);
            fillRoundRect(0,0,cWidth*6/10,cHeight,cHeight/40);

            //bottom ui+lifescreen
            this.ctx.shadowColor = "#b52d2d";
            this.ctx.shadowBlur = 20;
            this.ctx.shadowOffsetX = 0;
            this.ctx.shadowOffsetY = 0;
            this.ctx.fillStyle = "#f0f0f0";
            fillCircle(cWidth*1/3,cHeight*0.80,cWidth*0.08);
            this.ctx.fillRect(15,cHeight*3/4,(cWidth*2/3)-30,cHeight*0.1);
            this.ctx.fillRect(cWidth/20,0,(cWidth*2/3)-(cWidth/20)*2,cHeight);
            this.ctx.shadowColor = "#949494"
            fillCircle(cWidth*1/3,cHeight*0.80,cWidth*0.08);
            this.ctx.fillRect((cWidth*0.05)-7.5,cHeight*3/4,(cWidth*2/3)-(cWidth*0.1)+15,cHeight*0.1);
            
            this.ctx.fillStyle = "#e3e3e3";
            this.ctx.shadowColor = 'rgba(0,0,0,0)';
            this.ctx.fillRect(0,cHeight*6/8,cWidth*2/3,(cHeight*1/6));
            this.ctx.clearRect(0,cHeight*.8,cWidth*0.2,cHeight*.2);
            fillRoundRect(0,cHeight*6/8,cWidth*2/3,(cHeight*1/4)+1,cHeight/40);
            fillCircle(cWidth*1/3,cHeight*0.80,cWidth*0.08);
            this.ctx.fillStyle = "#0aad36";
            fillCircle(cWidth*1/3,cHeight*0.80,cWidth*0.075);
            this.ctx.fillStyle = "#e3e3e3";
            fillCircle(cWidth*1/3,cHeight*0.80,cWidth*0.073);
            this.ctx.fillStyle = "#0aad36";
            fillCircle(cWidth*1/3,cHeight*0.80,cWidth*0.070);
            this.ctx.fillStyle = "#e3e3e3";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.font = cHeight/25 + "px Avenir medium";
            this.ctx.fillText("Age",cWidth*1/3,cHeight*0.87);
            fillRoundRect((cWidth*1/3)-(cWidth*0.0070)/2,cHeight*0.70,cWidth*0.0070,cHeight*0.13,cHeight/40);
            fillRoundRect((cWidth*1/3)-(cHeight*0.13)/2,cHeight*0.76,(cHeight*0.13),(cWidth*0.0070),cHeight/40);
            


            displayCharts();

            //console.log("e");

            this.ctx.restore();
        }//display

        function displayCharts(){//will add scroll bar later
            this.ctx = board.context;

            this.ctx.fillStyle = "#03041a";

            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.fontSize = cWidth/40;
            this.ctx.font = fontSize+'px Avenir medium';
            this.ctx.fillText("Stats",cWidth*5/6,cHeight*1/10);

            this.ctx.textAlign = "right";
            this.fontSize = cWidth/70;
            this.ctx.font = fontSize+'px Avenir medium';
            for(i = 0;i<charts.length;i++){
                if(frameCount%1==0){
                    charts[i].updateStat();
                }
                let x = (cWidth*2/3)+cWidth/11;
                let y = (cHeight*1/6)+(this.fontSize*i*2);

                charts[i].display(x,y,this.fontSize*2);
            }
        }//displayCharts

        class Chart{
            constructor(name, stat){
                this.name = name;
                this.stat = stat;
                this.animStat = stat;
            }//constructor

            display(x,y,sp){
                this.ctx = board.context;
                this.ctx.fillStyle = "#03041a";
                this.ctx.textAlign = "right";
                this.ctx.font = sp/2 + "px Avenir medium";
                this.ctx.fillText(this.name,x,y);

                this.ctx.fillStyle = "#dedede";
                fillRoundRect(x+sp/3,y-sp/8,(cWidth*3/22),sp/4,cWidth/80)
                if(this.stat<25){
                    this.ctx.fillStyle = lerpColor([232, 19, 19],[250, 200, 2],this.stat*.01)
                }
                else{
                    this.ctx.fillStyle = lerpColor([250, 200, 2],[36, 245, 0],(this.stat*0.01)-0.25);
                }
                fillRoundRect(x+sp/3,y-sp/8,(cWidth*3/22)*this.animStat*0.01,sp/4,cWidth/80)

                this.ctx.fillStyle = "#03041a";
                this.ctx.textAlign = "left";
                this.ctx.fillText(this.animStat.toFixed(1)+"%",x+(cWidth*3/22)+sp/2,y);
            }//display

            updateStat(newStat){
                this.animStat+=(this.stat-this.animStat)/8;
                if((this.animStat-this.stat)*(this.animStat-this.stat)<=3){
                    this.animStat = this.stat;
                }
            }//updateStat

            changeStat(newStat){
                this.stat = roundToNearestTenth(newStat);
            }//changeStat
        }//Chart class

        class Human{



        }//Human

        class Log{
            constructor(){
                this.log;
            }//constructor

            
        }//Log

        //Helper Functions
        function fillRoundRect(x,y,w,l,r){
            this.ctx = board.context;

            this.ctx.beginPath();
            this.ctx.roundRect(x,y,w,l,r);
            this.ctx.fill();
            this.ctx.closePath();

        }//fillRoundRect - makes a filled rounded rectangle

        function fillCircle(x,y,r){
            this.ctx = board.context;

            this.ctx.beginPath();
            this.ctx.arc(x,y,r,0,2*Math.PI);
            this.ctx.fill();
            this.ctx.closePath();
        }//fillCircle - fills a circle..
        
        function lerp(x1,x2,v){
            return x1 * (1 - v) + x2 * v;
        }//lerp - gets an intermediate value between x1 and x2 based on v. v=1 will return x2

        function lerpColor(color1, color2, amt) {
            let r = lerp(color1[0], color2[0], amt);
            let g = lerp(color1[1], color2[1], amt);
            let b = lerp(color1[2], color2[2], amt);

            return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
        }//lerpColor 

        function getRandomInt(min, max) {
            const minCeiled = Math.ceil(min);
            const maxFloored = Math.floor(max);
            return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled);
        }//getRandomInt gets random integer with exclusive max and inclusive minimum

        function roundToNearestTenth(num) {
            return Math.round(num * 10)/10;
        }//roundToNearestTenth
    </script>

</body>
</html>